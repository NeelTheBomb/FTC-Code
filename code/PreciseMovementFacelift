package org.firstinspires.ftc.teamcode.lib;

// first
import org.firstinspires.ftc.teamcode.lib.Vector;
import org.firstinspires.ftc.teamcode.lib.MathStuff;

import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.hardware.bosch.BNO055IMU;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;

// our static stuff
import static org.firstinspires.ftc.teamcode.lib.MathStuff.sqr;
import static org.firstinspires.ftc.teamcode.lib.MathStuff.shortestAngleRemapped;


public class PreciseMovement {
    private static DcMotorEx fr;
    private static DcMotorEx fl;
    private static DcMotorEx br;
    private static DcMotorEx bl;
    private static BNO055IMU imu;

    // MovementPID
    private static double movementKp;
    private static double movementKi;
    private static double movementKd;
    private static double movementIntegralPrior;
    private static double movementErrorPrior;

    // AnglePID
    private static double angleKp;
    private static double angleKi;
    private static double angleKd;
    private static double angleIntegralPrior;
    private static double angleErrorPrior;

    private static double tolerance;
    private static double angleTolerance;

    // Positions and Motor Ticks
    private static double xPos;
    private static double yPos;

    private static double flPastTick;
    private static double frPastTick;
    private static double blPastTick;
    private static double brPastTick;


    /******* PUBLIC FUNCTIONS ********/
    public void init(BNO055IMU imu, DcMotorEx fr, DcMotorEx fl, DcMotorEx br, DcMotorEx bl) {
        PreciseMovement.fr = fr;
        PreciseMovement.fl = fl;
        PreciseMovement.br = br;
        PreciseMovement.bl = bl;
        PreciseMovement.imu = imu;

        PreciseMovement.movementKp = 0.5;
        PreciseMovement.movementKi = 0.0;
        PreciseMovement.movementKd = 0.0;
        PreciseMovement.movementIntegralPrior = 0.0;
        PreciseMovement.movementErrorPrior = 0.0;

        PreciseMovement.angleKp = 0.5;
        PreciseMovement.angleKi = 0.0;
        PreciseMovement.angleKd = 0.0;
        PreciseMovement.angleIntegralPrior = 0.0;
        PreciseMovement.angleErrorPrior = 0.0;

        PreciseMovement.tolerance = 10.0;
        PreciseMovement.angleTolerance = 0.05;

        PreciseMovement.xPos = 0.0;
        PreciseMovement.yPos = 0.0;
        PreciseMovement.flPastTick = 0.0;
        PreciseMovement.frPastTick = 0.0;
        PreciseMovement.blPastTick = 0.0;
        PreciseMovement.brPastTick = 0.0;

        fl.setDirection(DcMotor.Direction.REVERSE);
        bl.setDirection(DcMotor.Direction.REVERSE);
    }


    public boolean moveToPos(double targetPosX, double targetPosY, double iterationTime) {
        double[] moveConstants = desiredVector(xPos, yPos, targetPosX, targetPosY, iterationTime);

        robotMove(moveConstants[0], moveConstants[1], 0);

        return ((Math.abs(xPos - targetPosX) <= tolerance) && Math.abs(yPos - targetPosY) <= tolerance);
    }


    public boolean moveToAngle(double targetAngle, double iterationTime) {
        double[] angleValues = PID(angleKp, angleKd, angleKi, -imu.getAngularOrientation().firstAngle, targetAngle,
                angleIntegralPrior, angleErrorPrior, iterationTime);

        double angleDifference = angleValues[0];
        angleErrorPrior = angleValues[1];
        angleIntegralPrior = angleValues[2];
        robotMove(0, 0, angleDifference);

        return Math.abs(shortestAngleRemapped(currentAngle, targetAngle)) < angleTolerance;
    }


    public void updatePos() {
        double flTick = fl.getCurrentPosition() - flPastTick;
        double frTick = fr.getCurrentPosition() - frPastTick;
        double blTick = bl.getCurrentPosition() - blPastTick;
        double brTick = br.getCurrentPosition() - brPastTick;

        Vector currentVector = finalWheelVector(flTick, frTick, blTick, brTick, -imu.getAngularOrientation().firstAngle);
        double[] pos = newposition(xPos, yPos, currentVector);
        xPos = pos[0];
        yPos = pos[1];

        flPastTick = fl.getCurrentPosition();
        frPastTick = fr.getCurrentPosition();
        blPastTick = bl.getCurrentPosition();
        brPastTick = br.getCurrentPosition();
    }


    public double distanceFromPos(double targetPosX, double targetPosY) {
        return Math.sqrt(sqr(targetPosX-xPos) + sqr(targetPosY-yPos));
    }


    /******* GETTERS ********/
    public double[] getPos() { return new double[] { xPos, yPos }; }


    /******* SETTERS ********/
    // TODO: rename. What tolerance?
    public void setTolerance(double t) { tolerance = t; }

    public void setAngleTolerance(double t) { angleTolerance = t; }

    public void setMovementPID(double kp, double kd, double ki) {
        movementKp = kp;
        movementKd = kd;
        movementKi = ki;
        movementIntegralPrior = 0;
        movementErrorPrior = 0;
    }

    public void setAnglePID(double Kp, double Kd, double Ki) {
        angleKp = Kp;
        angleKd = Kd;
        angleKi = Ki;
        angleIntegralPrior = 0;
        angleErrorPrior = 0;
    }


    /******* PRIVATE FUNCTIONS ********/
    // TODO: rename double imu
    private Vector finalWheelVector(double deltaFl, double deltaFr, double deltaBl, double deltaBr, double imu) {
        Vector flvector = new Vector(deltaFl, Math.PI*0.25 + imu);
        Vector frvector = new Vector(deltaFr, Math.PI*0.75 + imu);
        Vector blvector = new Vector(deltaBl, Math.PI*0.75 + imu);
        Vector brvector = new Vector(deltaBr, Math.PI*0.25 + imu);

        Vector[] wheelVectors = new Vector[] { flvector, frvector, blvector, brvector };
        // just using a random vector to use the add function in the vector class
        Vector finalVector = blvector.add(wheelVectors);
        return new Vector(finalVector.getMagnitude(), finalVector.getAngle() + imu);
    }


    private double[] newPosition(double oldX, double oldY, Vector finalVector) {
        return new double[] { oldX + finalVector.getX(), oldY + finalVector.getY() };
    }


    // This will return an x and y value that describes how much the wheels should move
    // Think of this as the x and y of the joystick on last year's movement code
    // Divide constant adjusts how big the vector will be according to how faraway the desired position is
    // iterationTime should be in milliseconds
    private double[] desiredVector(double currentX, double currentY, double desiredX, double desiredY, double iterationTime) {
        double currentHypotenuse = Math.sqrt(sqr(currentX) * sqr(currentY));
        double desiredHypotenuse = Math.sqrt(sqr(desiredX) * sqr(desiredY));

        double[] wheelValues = PID(movementKp, movementKd, movementKi, currentHypotenuse, desiredHypotenuse,
                movementIntegralPrior, movementErrorPrior, iterationTime);

        movementErrorPrior = wheelValues[1];
        movementIntegralPrior = wheelValues[2];

        return new double[] { Math.cos(wheelValues[0]), Math.sin(wheelValues[0]) };
    }


    private void robotMove(double rotX, double rotY, double rx) {
        final double MAX_SPEED = 0.75;

        // Read inverse IMU heading, as the IMU heading is CW positive
        double botHeading = -imu.getAngularOrientation().firstAngle;

        rotX = (rotX * Math.cos(botHeading) - rotY * Math.sin(botHeading)) / 2;
        rotY = (rotX * Math.sin(botHeading) + rotY * Math.cos(botHeading)) / 2;

        double denominator = Math.max(Math.abs(rotY) + Math.abs(rotX) + (rx), 1);
        double frontLeftPower = (rotY + rotX - rx) / denominator;
        double backLeftPower = (rotY - rotX - rx) / denominator;
        double frontRightPower = (rotY - rotX + rx) / denominator;
        double backRightPower = (rotY + rotX  + rx) / denominator;

        fl.setPower(frontLeftPower * MAX_SPEED);
        bl.setPower(backLeftPower * MAX_SPEED);
        fr.setPower(frontRightPower * MAX_SPEED);
        br.setPower(backRightPower * MAX_SPEED);
    }


    private double[] PID(double kp, double kd, double ki, double actualValue, double desiredValue,
                         double integralPrior, double errorPrior, double iterationTime) {

        double error = desiredValue - actualValue;
        double integral = integralPrior + error * iterationTime;
        double derivative = (error - errorPrior) / iterationTime;
        double output = kp*error + ki*integral + kd*derivative;

        return new double[] { output, error, integral };
    }
}
